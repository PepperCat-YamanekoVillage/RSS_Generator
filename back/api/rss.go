package api

import (
	"back/database"
	"database/sql"
	"encoding/xml"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/antchfx/htmlquery"
	"github.com/gin-gonic/gin"
	"golang.org/x/net/html"
)

type RSS struct {
	XMLName xml.Name   `xml:"rss"`
	Version string     `xml:"version,attr"`
	Media   string     `xml:"xmlns:media,attr"`
	Channel RSSChannel `xml:"channel"`
}

type RSSChannel struct {
	Title       string    `xml:"title"`
	Description string    `xml:"description"`
	Link        string    `xml:"link"`
	PubDate     string    `xml:"pubDate"`
	Item        []RSSItem `xml:"item"`
}

type RSSItem struct {
	Title       string `xml:"title"`
	Link        string `xml:"link"`
	GUID        string `xml:"guid"`
	Description string `xml:"description,omitempty"`
	PubDate     string `xml:"pubDate,omitempty"`

	Thumbnail *MediaThumbnail `xml:"media:thumbnail,omitempty"`
}

type MediaThumbnail struct {
	URL string `xml:"url,attr"`
}

func RSSHandler(dataDB *sql.DB, xpathDB *sql.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		id := c.Query("id")
		isView := c.Query("isView")
		if id == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "missing id"})
			return
		}

		data, err := database.ReadData(dataDB, id)
		if err != nil {
			database.UpdateDataStatus(dataDB, id, 2)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to read data"})
			return
		}

		xpath, err := database.ReadXpath(xpathDB, id)
		if err != nil {
			database.UpdateDataStatus(dataDB, id, 2)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to read xpath"})
			return
		}

		rss, err := generateRSS(data.URL, id, xpath)
		if err != nil {
			database.UpdateDataStatus(dataDB, id, 2)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate rss"})
			return
		}

		if isView == "1" {
			c.Header("Content-Type", "text/xml")
		} else {
			c.Header("Content-Type", "application/rss+xml")
		}
		xmlData, err := xml.MarshalIndent(rss, "", "  ")
		if err != nil {
			database.UpdateDataStatus(dataDB, id, 2)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to marshal RSS"})
			return
		}

		database.UpdateDataStatus(dataDB, id, 1)
		c.String(http.StatusOK, xml.Header+string(xmlData))
	}
}

func generateRSS(url string, id string, xpath database.Xpath) (RSS, error) {
	doc, err := downloadHtml(url)
	if err != nil {
		return RSS{}, err
	}

	var items []RSSItem
	titleNodes, err := htmlquery.QueryAll(doc, xpath.Title)
	if err != nil {
		return RSS{}, err
	}
	descriptionNodes, errDes := htmlquery.QueryAll(doc, xpath.Description)
	dateNodes, errDat := htmlquery.QueryAll(doc, xpath.Date)
	thumbnailNodes, errTha := htmlquery.QueryAll(doc, xpath.Thumbnail)

	historyDB := database.OpenHistoryDB(id)
	defer historyDB.Close()

	for i, titleNode := range titleNodes {
		item := RSSItem{
			Title: htmlquery.InnerText(titleNode),
		}

		aNode := htmlquery.FindOne(titleNode, "ancestor-or-self::a[1]")
		if aNode == nil {
			aNode = htmlquery.FindOne(titleNode, ".//a[1]")
			if aNode == nil {
				return RSS{}, errors.New("No link found")
			}
		}
		item.Link = restoreFullURL(url, htmlquery.SelectAttr(aNode, "href"))
		item.GUID = item.Link

		if errDes == nil && i < len(descriptionNodes) {
			item.Description = htmlquery.InnerText(descriptionNodes[i])
		}

		if errDat == nil && i < len(dateNodes) {
			date, err := ParseAnyDateToRFC1123Z(htmlquery.InnerText(dateNodes[i]))
			if err == nil {
				item.PubDate = date
			} else {
				timestamp, err := database.ReadHistory(historyDB, item.GUID)
				if err == nil {
					item.PubDate = timestamp
				}
			}
		} else {
			timestamp, err := database.ReadHistory(historyDB, item.GUID)
			if err == nil {
				item.PubDate = timestamp
			}
		}

		if errTha == nil && i < len(thumbnailNodes) {
			item.Thumbnail = &MediaThumbnail{
				URL: restoreFullURL(url, htmlquery.SelectAttr(thumbnailNodes[i], "src")),
			}
		}

		items = append(items, item)
	}

	node := htmlquery.FindOne(doc, "//title")
	title := ""
	if node != nil {
		title = htmlquery.InnerText(node)
	}

	return RSS{
		Version: "2.0",
		Media:   "http://search.yahoo.com/mrss/",
		Channel: RSSChannel{
			Title:       title,
			Description: "Generated by shelf|RSS_Generator",
			Link:        url,
			PubDate:     time.Now().Format(time.RFC1123Z),
			Item:        items,
		},
	}, nil
}

func downloadHtml(url string) (*html.Node, error) {
	doc, err := htmlquery.LoadURL(url)
	if err != nil {
		return nil, err
	}
	return doc, nil
}

func extractElementFromHTML(doc *html.Node, xpath string) (string, error) {
	node, err := htmlquery.Query(doc, xpath)
	if err != nil {
		return "", err
	}

	if node != nil {
		return htmlquery.InnerText(node), nil
	}
	return "", err
}

func restoreFullURL(page_url, link_url string) string {
	parsedPageURL, err := url.Parse(page_url)
	if err != nil {
		return ""
	}

	if !strings.HasPrefix(link_url, "http://") && !strings.HasPrefix(link_url, "https://") {
		parsedLinkURL, err := parsedPageURL.Parse(link_url)
		if err != nil {
			return ""
		}
		return parsedLinkURL.String()
	}

	return link_url
}

func ParseAnyDateToRFC1123Z(dateStr string) (string, error) {
	layouts := []string{
		time.RFC1123Z,
		time.RFC3339,
		"2006-1-2",
		"2006-1-02",
		"2006-01-2",
		"2006-01-02",
		"2006/1/2",
		"2006/1/02",
		"2006/01/2",
		"2006/01/02",
		"2006-01-02 15:04:05",
		"2006/01/02 15:04:05",
	}

	for _, layout := range layouts {
		if t, err := time.Parse(layout, dateStr); err == nil {
			return t.Format(time.RFC1123Z), nil
		}
	}

	return "", fmt.Errorf("unsupported date format: %s", dateStr)
}
